module SkelBeatle where

-- Haskell module generated by the BNF converter

import AbsBeatle
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transTIdent :: TIdent -> Result
transTIdent x = case x of
  TIdent string -> failure x
transTPolyIdent :: TPolyIdent -> Result
transTPolyIdent x = case x of
  TPolyIdent string -> failure x
transVIdent :: VIdent -> Result
transVIdent x = case x of
  VIdent string -> failure x
transProgram :: Program -> Result
transProgram x = case x of
  Prog phrases -> failure x
transPhrase :: Phrase -> Result
transPhrase x = case x of
  Value letdef -> failure x
  Expression expr -> failure x
  TypeDecl typedef -> failure x
transLetDef :: LetDef -> Result
transLetDef x = case x of
  Let letbinds -> failure x
  LetRec letbinds -> failure x
transLetBind :: LetBind -> Result
transLetBind x = case x of
  ConstBind pattern expr -> failure x
  ProcBind procname patterns rtype expr -> failure x
transPNested :: PNested -> Result
transPNested x = case x of
  PAlgWild -> failure x
  PAlgList patterns -> failure x
transCasePat :: CasePat -> Result
transCasePat x = case x of
  CPattern pattern -> failure x
  CTypeAlgRec tident pnested -> failure x
  CNamedPat vident pattern -> failure x
  CListCons pattern1 pattern2 -> failure x
transPattern :: Pattern -> Result
transPattern x = case x of
  PId vident -> failure x
  PInt integer -> failure x
  PTrue -> failure x
  PFalse -> failure x
  PWildcard -> failure x
  PListEmpty -> failure x
  PTypeAlg tident -> failure x
  PTyped pattern type_ -> failure x
  PList patterns -> failure x
  PTypeAlgRec tident pnested -> failure x
  PNamedPat vident pattern -> failure x
  PListCons pattern1 pattern2 -> failure x
transExpr :: Expr -> Result
transExpr x = case x of
  EId vident -> failure x
  EInt integer -> failure x
  ETrue -> failure x
  EFalse -> failure x
  EListEmpty -> failure x
  ETypeAlg tident -> failure x
  EApp expr1 expr2 -> failure x
  ETyped expr type_ -> failure x
  ENeg expr -> failure x
  ENot expr -> failure x
  EMul expr1 expr2 -> failure x
  EDiv expr1 expr2 -> failure x
  EMod expr1 expr2 -> failure x
  EAdd expr1 expr2 -> failure x
  ESub expr1 expr2 -> failure x
  EListCons expr1 expr2 -> failure x
  ELTH expr1 expr2 -> failure x
  ELE expr1 expr2 -> failure x
  EGTH expr1 expr2 -> failure x
  EGE expr1 expr2 -> failure x
  EEQU expr1 expr2 -> failure x
  ENE expr1 expr2 -> failure x
  EAnd expr1 expr2 -> failure x
  EOr expr1 expr2 -> failure x
  ECond expr1 expr2 expr3 -> failure x
  ELetIn letdef expr -> failure x
  EMatch vident matchings -> failure x
  ELambda vidents expr -> failure x
  EList exprs -> failure x
  ETypeCons tident exprs -> failure x
transMatching :: Matching -> Result
transMatching x = case x of
  MatchCase casepat expr -> failure x
transProcName :: ProcName -> Result
transProcName x = case x of
  ProcNameId vident -> failure x
transTypeDef :: TypeDef -> Result
transTypeDef x = case x of
  TDef tident tpolyidents typeconss -> failure x
transTypeCons :: TypeCons -> Result
transTypeCons x = case x of
  TCons tident types -> failure x
transType :: Type -> Result
transType x = case x of
  TInt -> failure x
  TBool -> failure x
  TAlgebraic tident -> failure x
  TPoly tpolyident -> failure x
  TFun type_1 type_2 -> failure x
transRType :: RType -> Result
transRType x = case x of
  NoRetType -> failure x
  RetType type_ -> failure x

