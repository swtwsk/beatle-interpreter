-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParBeatle where
import AbsBeatle
import LexBeatle
import ErrM

}

%name pLine Line
%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  ',' { PT _ (TS _ 7) }
  '-' { PT _ (TS _ 8) }
  '->' { PT _ (TS _ 9) }
  '/' { PT _ (TS _ 10) }
  ':' { PT _ (TS _ 11) }
  '::' { PT _ (TS _ 12) }
  ';' { PT _ (TS _ 13) }
  ';;' { PT _ (TS _ 14) }
  '<' { PT _ (TS _ 15) }
  '<=' { PT _ (TS _ 16) }
  '=' { PT _ (TS _ 17) }
  '==' { PT _ (TS _ 18) }
  '>' { PT _ (TS _ 19) }
  '>=' { PT _ (TS _ 20) }
  '@' { PT _ (TS _ 21) }
  'Bool' { PT _ (TS _ 22) }
  'False' { PT _ (TS _ 23) }
  'Int' { PT _ (TS _ 24) }
  'True' { PT _ (TS _ 25) }
  '[' { PT _ (TS _ 26) }
  '[]' { PT _ (TS _ 27) }
  '\\' { PT _ (TS _ 28) }
  ']' { PT _ (TS _ 29) }
  '_' { PT _ (TS _ 30) }
  'also' { PT _ (TS _ 31) }
  'and' { PT _ (TS _ 32) }
  'case' { PT _ (TS _ 33) }
  'else' { PT _ (TS _ 34) }
  'if' { PT _ (TS _ 35) }
  'in' { PT _ (TS _ 36) }
  'let' { PT _ (TS _ 37) }
  'letrec' { PT _ (TS _ 38) }
  'match' { PT _ (TS _ 39) }
  'not' { PT _ (TS _ 40) }
  'of' { PT _ (TS _ 41) }
  'or' { PT _ (TS _ 42) }
  'then' { PT _ (TS _ 43) }
  'type' { PT _ (TS _ 44) }
  'with' { PT _ (TS _ 45) }
  '{' { PT _ (TS _ 46) }
  '|' { PT _ (TS _ 47) }
  '}' { PT _ (TS _ 48) }

L_integ  { PT _ (TI $$) }
L_TIdent { PT _ (T_TIdent $$) }
L_TPolyIdent { PT _ (T_TPolyIdent $$) }
L_VIdent { PT _ (T_VIdent $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
TIdent    :: { TIdent} : L_TIdent { TIdent ($1)}
TPolyIdent    :: { TPolyIdent} : L_TPolyIdent { TPolyIdent ($1)}
VIdent    :: { VIdent} : L_VIdent { VIdent ($1)}

Program :: { Program }
Program : ListPhrase { AbsBeatle.Prog (reverse $1) }
Line :: { Line }
Line : Phrase ';;' { AbsBeatle.Line $1 }
Phrase :: { Phrase }
Phrase : LetDef { AbsBeatle.Value $1 }
       | Expr { AbsBeatle.Expression $1 }
       | TypeDef { AbsBeatle.TypeDecl $1 }
ListPhrase :: { [Phrase] }
ListPhrase : {- empty -} { [] }
           | ListPhrase Phrase ';;' { flip (:) $1 $2 }
LetDef :: { LetDef }
LetDef : 'let' ListLetBind { AbsBeatle.Let $2 }
       | 'letrec' ListLetBind { AbsBeatle.LetRec $2 }
LetBind :: { LetBind }
LetBind : Pattern '=' Expr { AbsBeatle.ConstBind $1 $3 }
        | ProcName ListPattern RType '=' Expr { AbsBeatle.ProcBind $1 $2 $3 $5 }
ListPattern :: { [Pattern] }
ListPattern : Pattern { (:[]) $1 }
            | Pattern ListPattern { (:) $1 $2 }
ListLetBind :: { [LetBind] }
ListLetBind : LetBind { (:[]) $1 }
            | LetBind 'also' ListLetBind { (:) $1 $3 }
Pattern5 :: { Pattern }
Pattern5 : VIdent { AbsBeatle.PId $1 }
         | Integer { AbsBeatle.PInt $1 }
         | 'True' { AbsBeatle.PTrue }
         | 'False' { AbsBeatle.PFalse }
         | '_' { AbsBeatle.PWildcard }
         | '[]' { AbsBeatle.PListEmpty }
         | TIdent { AbsBeatle.PTypeAlg $1 }
         | '(' Pattern ':' Type ')' { AbsBeatle.PTyped $2 $4 }
         | '(' Pattern ')' { $2 }
Pattern4 :: { Pattern }
Pattern4 : '[' ListPattern4 ']' { AbsBeatle.PList $2 }
         | Pattern5 { $1 }
Pattern3 :: { Pattern }
Pattern3 : '(' TIdent PNested ')' { AbsBeatle.PTypeAlgRec $2 $3 }
         | Pattern4 { $1 }
Pattern2 :: { Pattern }
Pattern2 : VIdent '@' Pattern4 { AbsBeatle.PNamedPat $1 $3 }
         | Pattern3 { $1 }
Pattern1 :: { Pattern }
Pattern1 : Pattern5 '::' Pattern1 { AbsBeatle.PListCons $1 $3 }
         | Pattern2 { $1 }
PNested :: { PNested }
PNested : '_' { AbsBeatle.PAlgWild }
        | '(' ListPattern1 ')' { AbsBeatle.PAlgList $2 }
CasePat :: { CasePat }
CasePat : Pattern4 { AbsBeatle.CPattern $1 }
        | TIdent PNested { AbsBeatle.CTypeAlgRec $1 $2 }
        | VIdent '@' Pattern4 { AbsBeatle.CNamedPat $1 $3 }
        | Pattern5 '::' Pattern1 { AbsBeatle.CListCons $1 $3 }
ListPattern4 :: { [Pattern] }
ListPattern4 : Pattern4 { (:[]) $1 }
             | Pattern4 ',' ListPattern4 { (:) $1 $3 }
ListPattern1 :: { [Pattern] }
ListPattern1 : {- empty -} { [] }
             | Pattern1 { (:[]) $1 }
             | Pattern1 ',' ListPattern1 { (:) $1 $3 }
Pattern :: { Pattern }
Pattern : Pattern1 { $1 }
Expr9 :: { Expr }
Expr9 : VIdent { AbsBeatle.EId $1 }
      | Integer { AbsBeatle.EInt $1 }
      | 'True' { AbsBeatle.ETrue }
      | 'False' { AbsBeatle.EFalse }
      | '[]' { AbsBeatle.EListEmpty }
      | TIdent { AbsBeatle.ETypeAlg $1 }
      | '(' Expr ')' { $2 }
Expr8 :: { Expr }
Expr8 : Expr8 Expr9 { AbsBeatle.EApp $1 $2 } | Expr9 { $1 }
Expr7 :: { Expr }
Expr7 : '(' Expr ':' Type ')' { AbsBeatle.ETyped $2 $4 }
      | Expr8 { $1 }
Expr6 :: { Expr }
Expr6 : '-' Expr7 { AbsBeatle.ENeg $2 }
      | 'not' Expr7 { AbsBeatle.ENot $2 }
      | Expr7 { $1 }
Expr5 :: { Expr }
Expr5 : Expr5 '*' Expr6 { AbsBeatle.EMul $1 $3 }
      | Expr5 '/' Expr6 { AbsBeatle.EDiv $1 $3 }
      | Expr5 '%' Expr6 { AbsBeatle.EMod $1 $3 }
      | Expr6 { $1 }
Expr4 :: { Expr }
Expr4 : Expr4 '+' Expr5 { AbsBeatle.EAdd $1 $3 }
      | Expr4 '-' Expr5 { AbsBeatle.ESub $1 $3 }
      | Expr5 { $1 }
Expr3 :: { Expr }
Expr3 : Expr4 '::' Expr3 { AbsBeatle.EListCons $1 $3 }
      | Expr4 { $1 }
Expr2 :: { Expr }
Expr2 : Expr2 '<' Expr3 { AbsBeatle.ELTH $1 $3 }
      | Expr2 '<=' Expr3 { AbsBeatle.ELE $1 $3 }
      | Expr2 '>' Expr3 { AbsBeatle.EGTH $1 $3 }
      | Expr2 '>=' Expr3 { AbsBeatle.EGE $1 $3 }
      | Expr2 '==' Expr3 { AbsBeatle.EEQU $1 $3 }
      | Expr2 '!=' Expr3 { AbsBeatle.ENE $1 $3 }
      | Expr3 { $1 }
Expr1 :: { Expr }
Expr1 : Expr2 'and' Expr1 { AbsBeatle.EAnd $1 $3 } | Expr2 { $1 }
Expr :: { Expr }
Expr : Expr1 'or' Expr { AbsBeatle.EOr $1 $3 }
     | 'if' Expr 'then' Expr 'else' Expr { AbsBeatle.ECond $2 $4 $6 }
     | LetDef 'in' Expr { AbsBeatle.ELetIn $1 $3 }
     | 'match' VIdent 'with' '{' ListMatching '}' { AbsBeatle.EMatch $2 $5 }
     | '\\' ListVIdent '->' Expr { AbsBeatle.ELambda $2 $4 }
     | '[' ListExpr ']' { AbsBeatle.EList $2 }
     | TIdent 'of' '(' ListExpr ')' { AbsBeatle.ETypeCons $1 $4 }
     | Expr1 { $1 }
ListExpr :: { [Expr] }
ListExpr : Expr { (:[]) $1 } | Expr ',' ListExpr { (:) $1 $3 }
ListMatching :: { [Matching] }
ListMatching : Matching { (:[]) $1 }
             | Matching ';' ListMatching { (:) $1 $3 }
ListVIdent :: { [VIdent] }
ListVIdent : VIdent { (:[]) $1 }
           | VIdent ',' ListVIdent { (:) $1 $3 }
Matching :: { Matching }
Matching : 'case' CasePat '->' Expr { AbsBeatle.MatchCase $2 $4 }
ProcName :: { ProcName }
ProcName : VIdent { AbsBeatle.ProcNameId $1 }
TypeDef :: { TypeDef }
TypeDef : 'type' TIdent ListTPolyIdent '=' ListTypeCons { AbsBeatle.TDef $2 $3 $5 }
TypeCons :: { TypeCons }
TypeCons : TIdent ListType { AbsBeatle.TCons $1 (reverse $2) }
ListTPolyIdent :: { [TPolyIdent] }
ListTPolyIdent : {- empty -} { [] }
               | TPolyIdent ListTPolyIdent { (:) $1 $2 }
ListTypeCons :: { [TypeCons] }
ListTypeCons : TypeCons { (:[]) $1 }
             | TypeCons '|' ListTypeCons { (:) $1 $3 }
ListType :: { [Type] }
ListType : {- empty -} { [] } | ListType Type { flip (:) $1 $2 }
Type1 :: { Type }
Type1 : 'Int' { AbsBeatle.TInt }
      | 'Bool' { AbsBeatle.TBool }
      | TIdent { AbsBeatle.TAlgebraic $1 }
      | TPolyIdent { AbsBeatle.TPoly $1 }
      | '(' Type ')' { $2 }
Type :: { Type }
Type : Type1 '->' Type { AbsBeatle.TFun $1 $3 } | Type1 { $1 }
RType :: { RType }
RType : {- empty -} { AbsBeatle.NoRetType }
      | '->' Type { AbsBeatle.RetType $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

