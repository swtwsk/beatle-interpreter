

module AbsBeatle where

-- Haskell module generated by the BNF converter




newtype VIdent = VIdent String deriving (Eq, Ord, Show, Read)
data Program = Prog [Phrase]
  deriving (Eq, Ord, Show, Read)

data Line = Line Phrase
  deriving (Eq, Ord, Show, Read)

data Phrase = Value LetDef | Expression Expr
  deriving (Eq, Ord, Show, Read)

data LetDef = Let [LetBind] | LetRec [LetBind]
  deriving (Eq, Ord, Show, Read)

data LetBind
    = ConstBind LetLVI Expr | ProcBind ProcName [LetLVI] Expr
  deriving (Eq, Ord, Show, Read)

data LetLVI = LetLVI LambdaVI
  deriving (Eq, Ord, Show, Read)

data Pattern
    = PId VIdent
    | PInt Integer
    | PTrue
    | PFalse
    | PWildcard
    | PListEmpty
    | PList [Pattern]
    | PListCons Pattern Pattern
  deriving (Eq, Ord, Show, Read)

data Expr
    = EId VIdent
    | EInt Integer
    | ETrue
    | EFalse
    | EListEmpty
    | EList [Expr]
    | EApp Expr Expr
    | ENeg Expr
    | ENot Expr
    | EMul Expr Expr
    | EDiv Expr Expr
    | EMod Expr Expr
    | EAdd Expr Expr
    | ESub Expr Expr
    | EListCons Expr Expr
    | ELTH Expr Expr
    | ELE Expr Expr
    | EGTH Expr Expr
    | EGE Expr Expr
    | EEQU Expr Expr
    | ENE Expr Expr
    | EAnd Expr Expr
    | EOr Expr Expr
    | ECond Expr Expr Expr
    | ELetIn LetDef Expr
    | EMatch VIdent [Matching]
    | ELambda [LambdaVI] Expr
  deriving (Eq, Ord, Show, Read)

data LambdaVI = LambdaVId VIdent | WildVId
  deriving (Eq, Ord, Show, Read)

data Matching = MatchCase Pattern Expr
  deriving (Eq, Ord, Show, Read)

data ProcName = ProcNameId VIdent
  deriving (Eq, Ord, Show, Read)

