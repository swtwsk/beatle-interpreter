module Interpreter where

-- Haskell module generated by the BNF converter

import System.Console.Haskeline
import Control.Monad.State
import Control.Monad.Except
import qualified Data.Map as Map

import AbsBeatle
import Utils

import Lambda
import Values hiding (TypeDef(..))
import qualified Values as V
import qualified Expr as E


data InterRes = InterVal [(Value, E.Type)]
              | InterType Name [(Name, [E.Type])]

type TransRes = Either String
type Result = TransRes InterRes

type IState = StateT Env (ExceptT String (InputT IO))

data Fun = Fun [(E.Pattern, E.Type, E.Expr)] | Rec [(E.Pattern, E.Type, E.Expr)]

interpretLine :: Line -> IState Result
interpretLine (Line phr) = interpretPhrase phr

-- interpretProg :: Program -> [Result]
-- interpretProg (Prog phr) = map interpretPhrase phr

interpretPhrase :: Phrase -> IState Result
interpretPhrase (Expression e) = do
    env <- get
    ev <- return $ either Left (eval env) $ translateExpr e
    return $ either Left (\n -> return $ InterVal [n]) $ ev
interpretPhrase (Value letdef) = do
    env <- get
    let vmap = _values env
    tld <- either throwError return $ translateLetDef letdef
    m <- case tld of
        Fun list -> do
            _ <- either throwError return $
                mapM (\(_, t, e') -> typeEqualCheck env e' t) list
            either throwError return $ seqPair $ map (ev env) list
        Rec list -> do
            tlist <- mapM (either throwError return . extractVar) list
            let tmap  = Map.fromList tlist
                tmap' = Map.union tmap (_types env)
                env'  = env { _types = tmap' }
            _ <- either throwError return $ 
                mapM (\(_, _, e') -> typeCheck env' e') list
            return $ fixed env list
            where
                extractVar (E.PVar n, t, _) = pure (n, t)
                extractVar _ = Left "Patterns in letrecs: Unimplemented"
    ms <- mapM (either throwError return . extractVar) m
    let m' = map (\(n, v, _) -> (n, v)) ms
    let t' = map (\(n, _, t) -> (n, t)) ms
    put $ env { _values = Map.union (Map.fromList m') vmap
              , _types  = Map.union (Map.fromList t') (_types env) }
    extr <- return $ map extract m
    return . pure . InterVal $ extr
    where
        ev env (name, _, expr) = (name, eval env expr)
        extract (_, expr) = expr
        extractVar (E.PVar n, (v, t)) = pure (n, v, t)
        extractVar _ = Left "Patterns in letrecs: Unimplemented"
interpretPhrase (TypeDecl typedef) = do
    env <- get
    ttd <- either throwError return $ translateTypeDef typedef
    let (tname, tdef) = ttd
    let tmap = Map.insert tname tdef $ _algtypes env
    let cons = map (\(n, t) -> (n, (length t, tname))) $ V.consdef tdef
    let cmap = Map.union (Map.fromList cons) (_constructors env)
    put $ env { _constructors = cmap, _algtypes = tmap }
    return . pure $ InterType tname (V.consdef tdef)

translateExpr :: Expr -> TransRes E.Expr
translateExpr (EId (VIdent n)) = pure $ E.Var n
translateExpr (EInt i) = pure . E.Lit $ E.LInt i
translateExpr ETrue = pure . E.Lit $ E.LBool True
translateExpr EFalse = pure . E.Lit $ E.LBool False
translateExpr EListEmpty = pure . E.Lit $ E.LNil
translateExpr (EApp e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.App te1 te2
translateExpr (ETyped _ _) = Left "Unimplemented"
translateExpr (ENeg e) = do
    te <- translateExpr e
    pure $ E.UnOp E.OpNeg te
translateExpr (ENot e) = do
    te <- translateExpr e
    pure $ E.UnOp E.OpNot te
translateExpr (EMul e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpMul te1 te2
translateExpr (EDiv e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpDiv te1 te2
translateExpr (EAdd e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpAdd te1 te2
translateExpr (ESub e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpSub te1 te2
translateExpr (EMod e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ 
        E.BinOp E.OpSub te1 (E.BinOp E.OpMul te2 (E.BinOp E.OpDiv te1 te2))
translateExpr (EListCons e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.Cons te1 te2
translateExpr (ELTH e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpLT te1 te2
translateExpr (ELE e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpOr (E.BinOp E.OpLT te1 te2) (E.BinOp E.OpEq te1 te2)
translateExpr (EGTH e1 e2) = do
    le <- translateExpr (ELE e1 e2)
    pure $ E.UnOp E.OpNot le
translateExpr (EGE e1 e2) = do
    less <- translateExpr (ELTH e1 e2)
    pure $ E.UnOp E.OpNot less
translateExpr (EEQU e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpEq te1 te2
translateExpr (ENE e1 e2) = do
    eq <- translateExpr (EEQU e1 e2)
    pure $ E.UnOp E.OpNot eq
translateExpr (EAnd e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpAnd te1 te2
translateExpr (EOr e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpOr te1 te2
translateExpr (ECond cond e1 e2) = do
    tc <- translateExpr cond
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.If tc te1 te2

translateExpr (ELetIn letdef e) = do
    tl <- translateLetDef letdef
    te <- translateExpr e
    case tl of 
        Fun list -> pure $ transLambda list te
        Rec list -> pure $ E.LetRec list te
    where
        transLambda l e = case l of
            (n, _, fe):t -> E.Let n fe (transLambda t e)
            [] -> e

translateExpr (EMatch (VIdent n) matchList) = do
    ml <- mapM translateMatching matchList
    pure $ E.Case n ml

translateExpr (ELambda vlist e) = do
    te <- translateExpr e
    pure $ transLambda vlist te
    where 
        transLambda l e = case l of
            (TypedVId (VIdent n) typ):t -> 
                E.Lam (E.PVar n) (translateType typ) (transLambda t e)
            -- STUPID PLACEHOLDER
            (LambdaVId (VIdent n)):t -> E.Lam (E.PVar n) E.TInt (transLambda t e)
            (WildVId):t -> E.Lam (E.PVar "_") E.TInt (transLambda t e)
            [] -> e
translateExpr (EList elist) = do
    tlist <- sequence $ map translateExpr elist
    pure . trans $ tlist
    where 
        trans l = case l of
            h:t -> E.Cons h (trans t)
            [] -> E.Lit E.LNil
translateExpr (ETypeAlg (TIdent t)) = pure $ E.AlgCons t []
translateExpr (ETypeCons (TIdent t) elist) = do
    tlist <- sequence $ map translateExpr elist
    pure $ E.AlgCons t tlist

translateLetDef :: LetDef -> TransRes Fun
translateLetDef ld = case ld of
    Let letbinds -> 
        either Left (pure . Fun) $ sequence $ map translateLetBind letbinds
    LetRec letbinds -> 
        either Left (pure . Rec) $ sequence $ map translateLetBind letbinds

translateLetBind :: LetBind -> TransRes (E.Pattern, E.Type, E.Expr)
translateLetBind (ConstBind p e) = do
    tp <- translatePattern p
    let (n, t) = tp
    te <- translateExpr e
    pure (n, t, te)
translateLetBind (ProcBind (ProcNameId (VIdent proc)) pl rt e) = do
    tpl <- sequence $ map translatePattern pl
    te <- translateExpr e
    trt <- case translateRetType rt of
        Nothing -> Left "function return type not specified"
        Just trt' -> pure trt'
    let proctype = foldr (\(_, t) acc -> E.TFun t acc) trt tpl
    pure (E.PVar proc, proctype, transLambda tpl te)
    where
        transLambda l e = case l of
            (n, typ):t  -> E.Lam n typ (transLambda t e)
            [] -> e

translatePattern :: Pattern -> TransRes (E.Pattern, E.Type)
translatePattern (PId (VIdent n)) = Left "Pattern: VIdent unimplemented"
translatePattern (PTyped (PId (VIdent n)) t) = pure (E.PVar n, translateType t)
translatePattern (PInt i) = pure (E.PConst $ LInt i, E.TInt)
translatePattern PTrue = pure (E.PConst $ LBool True, E.TBool)
translatePattern PFalse = pure (E.PConst $ LBool False, E.TBool)
translatePattern PWildcard = Left "Pattern: Wildcard unimplemented"
translatePattern PListEmpty = Left "Pattern: cannot type empty list"
translatePattern _ = Left "Pattern: unimplemented"

translateMatching :: Matching -> TransRes (E.Pattern, E.Type, E.Expr)
translateMatching (MatchCase (CPattern p) expr) = do
    tp <- translatePattern p
    let (n, t) = tp
    te <- translateExpr expr
    pure $ (n, t, te)
translateMatching _ = Left "Matchcase: unimplemented"

translateTypeDef :: TypeDef -> TransRes (Name, V.TypeDef)
translateTypeDef (TDef (TIdent t) polys ltcons) = do
    let mpolys = map (\(TPolyIdent s) -> s) polys
    tl <- sequence $ map translateTypeCons ltcons
    return $ (t, V.TypeDef { V.polynames = mpolys, V.consdef = tl })

translateTypeCons :: TypeCons -> TransRes (Name, [E.Type])
translateTypeCons (TCons (TIdent t) types) = pure $ (t, map translateType types)

translateType :: Type -> E.Type
translateType TInt = E.TInt
translateType TBool = E.TBool
translateType (TList t) = E.TList $ translateType t
translateType (TAlgebraic (TIdent t)) = E.TAlg t
translateType (TPoly (TPolyIdent t)) = E.TPoly t
translateType (TFun t1 t2) = E.TFun (translateType t1) (translateType t2)

translateRetType :: RType -> Maybe E.Type
translateRetType NoRetType = Nothing
translateRetType (RetType t) = pure $ translateType t
