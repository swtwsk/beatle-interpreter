module Interpreter where

-- Haskell module generated by the BNF converter

import System.Console.Haskeline
import Control.Monad.State
import Control.Monad.Except
import Data.Functor.Identity
import qualified Data.Map as Map

import AbsBeatle
import Utils

import Lambda
import Values hiding (TypeDef(..))
import qualified Values as V
import qualified Expr as E


data InterRes = InterVal [(Value, E.Type)]
              | InterType Name [(Name, [E.Type])]

type TransRes = Either String
type Result = TransRes InterRes

type IState = StateT Env (ExceptT String (InputT IO))

data Fun = Fun [(Name, E.SchemeMap, E.Expr)] | Rec [(Name, E.SchemeMap, E.Expr)]

interpretLine :: Line -> IState Result
interpretLine (Line phr) = interpretPhrase phr

-- interpretProg :: Program -> [Result]
-- interpretProg (Prog phr) = map interpretPhrase phr

interpretPhrase :: Phrase -> IState Result
interpretPhrase (Expression e) = do
    env <- get
    ev <- return $ either Left (eval env) $ translateExpr e
    return $ either Left (\n -> return $ InterVal [n]) $ ev
interpretPhrase (Value letdef) = do
    env <- get
    let vmap = _values env
    tld <- either throwError return $ translateLetDef letdef
    m <- case tld of
        Fun list -> do
            let tmap   = map (\(_, s, _) -> s) list
                tmap'  = foldr Map.union Map.empty tmap
                tmap'' = Map.union tmap'' (_schemes env)
                tenv   = env { _schemes = tmap'' }
            _ <- either throwError return $ 
                mapM (\(_, t, e') -> typeCheck env e') list
            either throwError return $ seqPair $ map (ev env) list
        Rec list -> throwError "Rec unimplemented"
            -- do
            -- tlist <- mapM (either throwError return . extractVar) list
            -- let tmap  = Map.fromList tlist
            --     tmap' = Map.union tmap (_schemes env)
            --     env'  = env { _schemes = tmap' }
            -- _ <- either throwError return $ 
            --     mapM (\(_, _, e') -> typeCheck env' e') list
            -- return $ fixed env list
            -- where
            --     extractVar (n, t, _) = pure (n, t)
    ms <- mapM (either throwError return . extractVar) m
    let m' = map (\(n, v, _) -> (n, v)) ms
    let t' = map (\(n, _, t) -> 
            (n, E.generalize (E.GammaEnv $ _schemes env) t)) ms
    put $ env { _values = Map.union (Map.fromList m') vmap
              , _schemes  = Map.union (Map.fromList t') (_schemes env) }
    extr <- return $ map extract m
    return . pure . InterVal $ extr
    where
        ev env (name, _, expr) = (name, eval env expr)
        extract (_, expr) = expr
        extractVar (n, (v, t)) = pure (n, v, t)
interpretPhrase (TypeDecl typedef) = do
    env <- get
    ttd <- either throwError return $ translateTypeDef typedef
    let (tname, tdef) = ttd
    let tmap = Map.insert tname tdef $ _algtypes env
    let cons = map (\(n, t) -> (n, (length t, tname))) $ V.consdef tdef
    let cmap = Map.union (Map.fromList cons) (_constructors env)
    put $ env { _constructors = cmap, _algtypes = tmap }
    return . pure $ InterType tname (V.consdef tdef)

translateExpr :: Expr -> TransRes E.Expr
translateExpr (EId (VIdent n)) = pure $ E.Var n
translateExpr (EInt i) = pure . E.Lit $ E.LInt i
translateExpr ETrue = pure . E.Lit $ E.LBool True
translateExpr EFalse = pure . E.Lit $ E.LBool False
translateExpr EListEmpty = pure . E.Lit $ E.LNil
translateExpr (EApp e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.App te1 te2
translateExpr (ETyped e t) = do
    te <- translateExpr e
    let tt = translateType t
    pure $ E.Typed te tt
translateExpr (ENeg e) = do
    te <- translateExpr e
    pure $ E.UnOp E.OpNeg te
translateExpr (ENot e) = do
    te <- translateExpr e
    pure $ E.UnOp E.OpNot te
translateExpr (EMul e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpMul te1 te2
translateExpr (EDiv e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpDiv te1 te2
translateExpr (EAdd e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpAdd te1 te2
translateExpr (ESub e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpSub te1 te2
translateExpr (EMod e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ 
        E.BinOp E.OpSub te1 (E.BinOp E.OpMul te2 (E.BinOp E.OpDiv te1 te2))
translateExpr (EListCons e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.Cons te1 te2
translateExpr (ELTH e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpLT te1 te2
translateExpr (ELE e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpOr (E.BinOp E.OpLT te1 te2) (E.BinOp E.OpEq te1 te2)
translateExpr (EGTH e1 e2) = do
    le <- translateExpr (ELE e1 e2)
    pure $ E.UnOp E.OpNot le
translateExpr (EGE e1 e2) = do
    less <- translateExpr (ELTH e1 e2)
    pure $ E.UnOp E.OpNot less
translateExpr (EEQU e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpEq te1 te2
translateExpr (ENE e1 e2) = do
    eq <- translateExpr (EEQU e1 e2)
    pure $ E.UnOp E.OpNot eq
translateExpr (EAnd e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpAnd te1 te2
translateExpr (EOr e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpOr te1 te2
translateExpr (ECond cond e1 e2) = do
    tc <- translateExpr cond
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.If tc te1 te2

translateExpr (ELetIn letdef e) = do
    tl <- translateLetDef letdef
    te <- translateExpr e
    case tl of 
        Fun list -> pure $ transLambda list te
        Rec list -> throwError "Rec not implemented"
            -- pure $ E.LetRec list te
    where
        transLambda l e = case l of
            (n, _, fe):t -> E.Let n fe (transLambda t e)
            [] -> e

translateExpr (EMatch (VIdent n) matchList) = do
    ml <- mapM translateMatching matchList
    pure $ E.Case n ml

translateExpr (ELambda vlist e) = do
    te <- translateExpr e
    pure $ transLambda vlist te
    where 
        transLambda l e = case l of
            h:t -> extract (translateLambdaVI h) (transLambda t e)
            [] -> e
        extract (n, Just t) l = E.Lam (E.PTyped (E.PVar n) t) l
        extract (n, _) l = E.Lam (E.PVar n) l
translateExpr (EList elist) = do
    tlist <- sequence $ map translateExpr elist
    pure . trans $ tlist
    where 
        trans l = case l of
            h:t -> E.Cons h (trans t)
            [] -> E.Lit E.LNil
translateExpr (ETypeAlg (TIdent t)) = pure $ E.AlgCons t []
translateExpr (ETypeCons (TIdent t) elist) = do
    tlist <- sequence $ map translateExpr elist
    pure $ E.AlgCons t tlist

translateLetDef :: LetDef -> TransRes Fun
translateLetDef ld = case ld of
    Let letbinds -> 
        either Left (pure . Fun) $ sequence $ map translateLetBind letbinds
    LetRec letbinds -> 
        either Left (pure . Rec) $ sequence $ map translateLetBind letbinds

translateLetBind :: LetBind -> TransRes (Name, E.SchemeMap, E.Expr)
translateLetBind (ConstBind lvi e) = do
    tlvi <- translateLetLVI lvi
    let (n, t) = tlvi
    let nt = E.TVar "a"
        t' = Map.singleton n $ E.Scheme [] $ maybe nt id t
    te <- translateExpr e
    pure (n, t', te)
translateLetBind (ProcBind (ProcNameId (VIdent proc)) il rt e) = do
    til <- sequence $ map translateLetLVI il
    te <- translateExpr e
    let trt = translateRetType rt
        (vars, untyped) = giveTypeNames $ (map (\(_, t) -> t) til) ++ [trt]
        (params, ret) = splitLast untyped
        proctype = foldr (\t acc -> E.TFun t acc) ret params
        scheme = E.Scheme [] proctype
    pure (proc, Map.singleton proc scheme, transLambda til te)
    where
        transLambda l e = case l of
            (n, Just typ):t  -> 
                E.Lam (E.PTyped (E.PVar n) typ) (transLambda t e)
            (n, _):t  -> E.Lam (E.PVar n) (transLambda t e)
            [] -> e
        splitLast :: [a] -> ([a], a)
        splitLast l = case l of
            h:t -> let (init, last) = splitLast t in (h:init, last)
            h:[] -> ([], h)
        -- we may do splitLast because procedure has at least one argument

data TypeState = TypeState { _supply :: String, _vars :: [String] }
type TypeNameState = StateT TypeState Identity E.Type

emptyTypeState :: TypeState
emptyTypeState = TypeState { _supply = "\'a",
                             _vars   = ["\'a"] }

freshName :: TypeNameState
freshName = do
    s <- get
    let c@(h:t) = _supply s
        next    = if h == 'z' then "\'a" ++ c else '\'':(succ h):t
    put s { _supply = next, _vars = next:(_vars s) }
    return $ E.TVar c

giveTypeNames :: [Maybe E.Type] -> ([String], [E.Type])
giveTypeNames l = 
    let (res, st) = runState (mapM giveTypeNames' l) emptyTypeState in
        ((_vars st), res)
    where
        giveTypeNames' :: Maybe E.Type -> TypeNameState
        giveTypeNames' (Just t)  = return t
        giveTypeNames' Nothing = freshName

translateLetLVI :: LetLVI -> TransRes (Name, Maybe E.Type)
translateLetLVI (LetLVI lvi) = pure $ translateLambdaVI lvi

translateLambdaVI :: LambdaVI -> (Name, Maybe E.Type)
translateLambdaVI (TypedVId (VIdent n) typ) = (n, pure $ translateType typ)
translateLambdaVI (LambdaVId (VIdent n)) = (n, Nothing)
translateLambdaVI (WildVId) = ("_", Nothing)

translatePattern :: Pattern -> TransRes E.Pattern
translatePattern (PId (VIdent n)) = pure $ E.PVar n
translatePattern (PTyped p t) = do
    tp <- translatePattern p
    let tt = translateType t
    pure $ E.PTyped tp tt
translatePattern (PInt i) = pure . E.PConst $ LInt i
translatePattern PTrue = pure . E.PConst $ LBool True
translatePattern PFalse = pure . E.PConst $ LBool False
translatePattern PWildcard = pure . E.PVar $ "_"
translatePattern PListEmpty = pure . E.PConst $ LNil
translatePattern (PTypeAlg t) = Left "Pattern: PTypeAlg unimplemented"
translatePattern (PList plist) = do
    tlist <- sequence $ map translatePattern plist
    pure . trans $ tlist
    where 
        trans l = case l of
            h:t -> E.PCons h (trans t)
            []  -> E.PConst E.LNil
translatePattern (PTypeAlgRec tid pnest) = 
    Left "Pattern: PTypeAlgRec unimplemented"
translatePattern (PNamedPat vid pat) = 
    Left "Pattern: PNamedPat unimplemented"
translatePattern (PListCons p1 p2) = do
    tp1 <- translatePattern p1
    tp2 <- translatePattern p2
    pure $ E.PCons tp1 tp2

translateMatching :: Matching -> TransRes (E.Pattern, E.Expr)
translateMatching (MatchCase p expr) = do
    tp <- translatePattern p
    te <- translateExpr expr
    pure $ (tp, te)

translateTypeDef :: TypeDef -> TransRes (Name, V.TypeDef)
translateTypeDef (TDef (TIdent t) polys ltcons) = do
    let mpolys = map (\(TPolyIdent s) -> s) polys
    tl <- sequence $ map translateTypeCons ltcons
    return $ (t, V.TypeDef { V.polynames = mpolys, V.consdef = tl })

translateTypeCons :: TypeCons -> TransRes (Name, [E.Type])
translateTypeCons (TCons (TIdent t) types) = pure $ (t, map translateType types)

translateType :: Type -> E.Type
translateType TInt = E.TInt
translateType TBool = E.TBool
translateType (TList t) = E.TList $ translateType t
translateType (TAlgebraic (TIdent t)) = E.TAlg t
translateType (TPoly (TPolyIdent t)) = E.TVar t
translateType (TFun t1 t2) = E.TFun (translateType t1) (translateType t2)

translateRetType :: RType -> Maybe E.Type
translateRetType NoRetType = Nothing
translateRetType (RetType t) = pure $ translateType t
