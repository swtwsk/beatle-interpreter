module Interpreter where

-- Haskell module generated by the BNF converter

import System.Console.Haskeline
import Control.Monad.State
import Control.Monad.Except
import Data.Functor.Identity
import qualified Data.Map as Map

import AbsBeatle
import Utils

import Lambda
import Values hiding (TypeDef(..))
import qualified Values as V
import qualified Expr as E


data InterRes = InterVal [(Maybe Name, Value, E.Type)]
              | InterType Name [(Name, [E.Type])]

type TransRes = Either String
type Result = TransRes InterRes

type IState = StateT Env (ExceptT String (InputT IO))

data Fun = Fun [(Name, E.Expr)] | Rec [(Name, E.Expr)]

interpretLine :: Line -> IState Result
interpretLine (Line phr) = interpretPhrase phr

-- interpretProg :: Program -> [Result]
-- interpretProg (Prog phr) = map interpretPhrase phr

interpretPhrase :: Phrase -> IState Result
interpretPhrase (Expression e) = do
    env <- get
    let ev = either Left (eval env) $ translateExpr e
    return $ either Left (\(v, t) -> return $ InterVal [(Nothing, v, t)]) ev
interpretPhrase (Value letdef) = do
    env <- get
    let vmap = _values env
    tld <- either throwError return $ translateLetDef letdef
    m <- case tld of
        Fun list -> either throwError return $ seqPair $ map (ev env) list
        Rec list -> do
            let sm   = _schemes env
                alg  = _algtypes env
                cons = _constructors env
            ty <- either throwError return $ E.inferTypeRec sm (alg, cons) list
            return $ zipType (fixed env list) ty
            where
                zipType ((n, v):tv) t = (n, (v, t)) : zipType tv t
                zipType [] _ = []
    ms <- mapM (either throwError return . extractVar) m
    let m' = map (\(n, v, _) -> (n, v)) ms
    let t' = map (\(n, _, t) -> (n, E.Scheme [] t)) ms
    put $ env { _values = Map.union (Map.fromList m') vmap
              , _schemes  = Map.union (Map.fromList t') (_schemes env) }
    let extr = map (\(n, v, t) -> (pure n, v, t)) ms
    return . pure . InterVal $ extr
    where
        ev env (name, expr) = (name, eval env expr)
        extractVar (n, (v, t)) = pure (n, v, t)
interpretPhrase (TypeDecl typedef) = do
    env <- get
    ttd <- either throwError return $ translateTypeDef typedef
    let (tname, tdef) = ttd
    let tmap = Map.insert tname tdef $ _algtypes env
    let cons = map (\(n, _) -> (n, tname)) $ E._consdef tdef
    let cmap = Map.union (Map.fromList cons) (_constructors env)
    put $ env { _constructors = cmap, _algtypes = tmap }
    return . pure $ InterType tname (E._consdef tdef)

translateExpr :: Expr -> TransRes E.Expr
translateExpr (EId (VIdent n)) = pure $ E.Var n
translateExpr (EInt i) = pure . E.Lit $ E.LInt i
translateExpr ETrue = pure . E.Lit $ E.LBool True
translateExpr EFalse = pure . E.Lit $ E.LBool False
translateExpr EListEmpty = pure . E.Lit $ E.LNil
translateExpr (EApp e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.App te1 te2
translateExpr (ENeg e) = do
    te <- translateExpr e
    pure $ E.UnOp E.OpNeg te
translateExpr (ENot e) = do
    te <- translateExpr e
    pure $ E.UnOp E.OpNot te
translateExpr (EMul e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpMul te1 te2
translateExpr (EDiv e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpDiv te1 te2
translateExpr (EAdd e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpAdd te1 te2
translateExpr (ESub e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpSub te1 te2
translateExpr (EMod e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ 
        E.BinOp E.OpSub te1 (E.BinOp E.OpMul te2 (E.BinOp E.OpDiv te1 te2))
translateExpr (EListCons e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.Cons te1 te2
translateExpr (ELTH e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpLT te1 te2
translateExpr (ELE e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpOr (E.BinOp E.OpLT te1 te2) (E.BinOp E.OpEq te1 te2)
translateExpr (EGTH e1 e2) = do
    le <- translateExpr (ELE e1 e2)
    pure $ E.UnOp E.OpNot le
translateExpr (EGE e1 e2) = do
    less <- translateExpr (ELTH e1 e2)
    pure $ E.UnOp E.OpNot less
translateExpr (EEQU e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpEq te1 te2
translateExpr (ENE e1 e2) = do
    eq <- translateExpr (EEQU e1 e2)
    pure $ E.UnOp E.OpNot eq
translateExpr (EAnd e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpAnd te1 te2
translateExpr (EOr e1 e2) = do
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.BinOp E.OpOr te1 te2
translateExpr (ECond cond e1 e2) = do
    tc <- translateExpr cond
    te1 <- translateExpr e1
    te2 <- translateExpr e2
    pure $ E.If tc te1 te2

translateExpr (ELetIn letdef e) = do
    tl <- translateLetDef letdef
    te <- translateExpr e
    case tl of 
        Fun list -> pure $ transLambda list te
        Rec list -> pure $ E.LetRec list te
    where
        transLambda l e = case l of
            (n, fe):t -> E.Let n fe (transLambda t e)
            [] -> e

translateExpr (EMatch (VIdent n) matchList) = do
    ml <- mapM translateMatching matchList
    pure $ E.Case n ml

translateExpr (ELambda vlist e) = do
    te <- translateExpr e
    pure $ transLambda vlist te
    where 
        transLambda l e = case l of
            h:t -> E.Lam (E.PVar $ translateLambdaVI h) (transLambda t e)
            [] -> e
translateExpr (EList elist) = do
    tlist <- mapM translateExpr elist
    pure . trans $ tlist
    where 
        trans l = case l of
            h:t -> E.Cons h (trans t)
            [] -> E.Lit E.LNil
translateExpr (ETypeAlg (TIdent t)) = pure $ E.AlgCons t []
translateExpr (ETypeCons (TIdent t) elist) = do
    tlist <- mapM translateExpr elist
    pure $ E.AlgCons t tlist

translateLetDef :: LetDef -> TransRes Fun
translateLetDef ld = case ld of
    Let letbinds -> 
        either Left (pure . Fun) $ mapM translateLetBind letbinds
    LetRec letbinds -> 
        either Left (pure . Rec) $ mapM translateLetBind letbinds

translateLetBind :: LetBind -> TransRes (Name, E.Expr)
translateLetBind (ConstBind lvi e) = do
    n <- translateLetLVI lvi
    te <- translateExpr e
    pure (n, te)
translateLetBind (ProcBind (ProcNameId (VIdent proc)) il e) = do
    til <- mapM translateLetLVI il
    te <- translateExpr e
    pure (proc, transLambda til te)
    where
        transLambda l e = case l of
            n:t  -> E.Lam (E.PVar n) (transLambda t e)
            [] -> e

translateLetLVI :: LetLVI -> TransRes Name
translateLetLVI (LetLVI lvi) = pure $ translateLambdaVI lvi

translateLambdaVI :: LambdaVI -> Name
translateLambdaVI (LambdaVId (VIdent n)) = n
translateLambdaVI WildVId = "_"

translatePattern :: Pattern -> TransRes E.Pattern
translatePattern (PId (VIdent n)) = pure $ E.PVar n
translatePattern (PInt i) = pure . E.PConst $ LInt i
translatePattern PTrue = pure . E.PConst $ LBool True
translatePattern PFalse = pure . E.PConst $ LBool False
translatePattern PWildcard = pure . E.PVar $ "_"
translatePattern PListEmpty = pure . E.PConst $ LNil
translatePattern (PTypeAlg t) = Left "Pattern: PTypeAlg unimplemented"
translatePattern (PList plist) = do
    tlist <- mapM translatePattern plist
    pure . trans $ tlist
    where 
        trans l = case l of
            h:t -> E.PCons h (trans t)
            []  -> E.PConst E.LNil
translatePattern (PTypeAlgRec tid pnest) = 
    Left "Pattern: PTypeAlgRec unimplemented"
translatePattern (PListCons p1 p2) = do
    tp1 <- translatePattern p1
    tp2 <- translatePattern p2
    pure $ E.PCons tp1 tp2

translateMatching :: Matching -> TransRes (E.Pattern, E.Expr)
translateMatching (MatchCase p expr) = do
    tp <- translatePattern p
    te <- translateExpr expr
    pure (tp, te)

translateTypeDef :: TypeDef -> TransRes (Name, E.TypeDef)
translateTypeDef (TDef (TIdent t) polys ltcons) = do
    let mpolys = map (\(TPolyIdent s) ->  E.TVar s) polys
    tl <- mapM translateTypeCons ltcons
    let check = all (checkType mpolys) $ flattenTypes tl
    if not check then Left "Unbound type parameters" else return 
        (t, E.TypeDef { E._polys = mpolys, E._consdef = tl })
    where
        flattenTypes ((_, ts):t) = ts ++ flattenTypes t
        flattenTypes [] = []
        checkType pols t@(E.TVar _) = t `elem` pols
        checkType _ _ = True

translateTypeCons :: TypeCons -> TransRes (Name, [E.Type])
translateTypeCons (TCons (TIdent t) types) = pure (t, map translateType types)

translateType :: Type -> E.Type
translateType TInt = E.TInt
translateType TBool = E.TBool
translateType (TList t) = E.TList $ translateType t
translateType (TAlgebraic (TIdent t)) = E.TAlg t
translateType (TPoly (TPolyIdent t)) = E.TVar t
translateType (TFun t1 t2) = E.TFun (translateType t1) (translateType t2)
